%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% 情報通信システム工学科 卒業論文テンプレート
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt]{icsthesis}
\usepackage[dvipdfmx]{graphicx}
\usepackage[fleqn]{amsmath}
\usepackage{fancyhdr}
\usepackage{bm}
\usepackage{bigstrut}
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{float}

\usepackage{listings}
\renewcommand{\lstlistingname}{表}
\usepackage{framed}

\usepackage{algpseudocode}
\usepackage{algorithm}
\renewcommand{\thealgorithm}{} % アルゴリズムの番号を消す

%%----------------------------------------------------------------------------------------------------------------------
%% 表紙の記載事項
%%----------------------------------------------------------------------------------------------------------------------
%% ToDo: 論文タイトル
\title{DTNを用いた効率的メッセージ\\交換に関する研究}
%% ToDo: 著者一覧
\authorA{21A5041}{記内　勇太}
\authorB{21A5101}{古山　孔亮}
%\authorC{21A5003}{氏　名3}
%\authorD{21A5004}{氏　名4}

%% ToDo: 指導教員
\supervisor{菅原　真司 教授}

%% ToDo: 提出日
\date{令和7年1月30日}

%%----------------------------------------------------------------------------------------------------------------------
\begin{document}
\maketitle
%-----------------------------------------------------------
% ヘッダ・フッタ設定
\pagestyle{fancy}
\fancyhead[R]{\nouppercase{\fontsize{10.5pt}{0pt}\selectfont\rightmark}}
\fancyhead[L]{\nouppercase{\fontsize{10.5pt}{0pt}\selectfont\leftmark}}
%\fancyhead[R]{\nouppercase{\small\rightmark}}
%\fancyhead[L]{\nouppercase{\small\leftmark}}
\fancyfoot[C]{--\ \thepage\ --}
\renewcommand{\headrulewidth}{0.3truemm}
%-----------------------------------------------------------
%% 目次
\pagenumbering{roman}
\setcounter{tocdepth}{4}
\pagestyle{fancy}
\fancyfoot[C]{--\ \thepage\ --}
{\makeatletter
\let\ps@jpl@in\ps@empty
\makeatother
\pagestyle{plain}
\tableofcontents
\clearpage}
\pagenumbering{arabic}
%%======================================================================================================================
%% ここから本文 ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%%======================================================================================================================

%%=============第１章=============
\chapter{序論}
近年，インターネットは，情報交換・共有システムの一部として，社会・経済のインフラストラクチャの役割を担っている．しかし，全ての地域に高度な通信サービスを提供することは，コストが掛かる上に周波数の有限性から現実的ではない．また，ディジタルデバイド地域のインフラ構築，災害時等に本来の通信インフラの機能や性能が低下・停止した場合の対処を考え，場所・時間を問わず利用できる情報通信サービスの実現が必要とされている．

そこで，従来では想定されていなかった環境を含むエンドツーエンドの情報伝達において，従来のTCP/IP（Transmission Control Protocol/Internet Protocol）技術を拡張し，中継ノード及びエンドノードの機能を再設計する必要がある．昔から車や人等が移動して物理的に情報を運ぶやり方は存在していた．それらをTCP/IP技術の問題認識から発生した技術領域としてインターネット通信の枠組みで考えられたのが，DTNである[1]．

TCP/IP技術におけるDTNの概念はビントン・サーフ氏によって提案された惑星間インターネットの構想が基になっている．その惑星間インターネットには2つの大きな問題点が挙げられる．まず，惑星間というのは光速で進む電波であっても，届くのに長い時間を要する．次に，通信機が惑星によって見えなくなり，その間，通信が途絶える．これらの問題をそれぞれ，「通信遅延」，「通信途絶」として研究されてきた[2]．

DTNの特徴的な技術として，蓄積運搬形転送がある．これは，再開を待つ，あるいは最適なタイミングを待つための一時的「蓄積」と，物理的に車や列車を用いて情報を運ぶ「運搬」を用いる必要がある．そのような人や車等における蓄積運搬形転送の中で，疎密状態モバイルアドホック網における感染形中継転送方式（以降，Epidemic Routing）が確率的中継転送方式の最も代表的な方式として存在する．Epidemic Routingでは，ノードの移動や遭遇，送信を繰り返すことで全てのノードにデータを流通させる[1][3]．結果的に伝染病のように広がり，いずれかのメッセージが宛先端末に到達することになる．しかし，Epidemic Routingではメッセージの到達を引き換えに，端末のバッファや網内に多くの複製メッセージが残存してしまう．そのため，Recovery Scheme（回復手法）やAnti Packet（除去パケット）を使用したルーティング手法等が提案されてきた[1]．

本研究では，DTN環境において，メッセージやバッファ等の資源を効率良く管理することで，必然的にメッセージは宛先に届けやすくなるのではないかと考えた．従来手法には，複製メッセージの残存による網内資源の浪費や宛先に届けられる可能性の高かったメッセージの削除といった問題点が存在していた．実験においては，それらの問題を解決することを念頭に置き，「データ到達率」，「メッセージ平均遅延時間」，「メッセージ削除数」を評価指標として，ネットワーク負荷の削減・効率的なメッセージ転送の実現を目指す．

%%=============第２章=============
\chapter{DTNにおける従来手法とその問題}
\section{DTN}
DTNとは，Delay，Disruption，Disconnection Tolerant Networkingの略で，大きな遅延や通信途絶，繋がっていない状態の方が多い環境においても，適切な情報通信を現実的なコストで実現できる技術であり，蓄積運搬型の中継転送を利用することにより，エンドツーエンドの通信を可能とする[5]．要素技術として，バンドルプロトコルとストアアンドフォワード方式が存在する．インターネットでのデータ転送にはトランスポート層のTCPを使用するが，通信に遅延や切断が生じると，通信品質が劣化してしまう．そのため，TCPによる通信では，エンドツーエンドのリンクが安定している必要がある．DTNでは，不安定なリンクにも対応しなければならないため，トランスポート層の上に「バンドル」と呼ばれるプロトコルを乗せることで劣通信環境に対応する．バンドルプロトコルの中でも，データ転送にはストアアンドフォワード方式を用いる[4]．ストアアンドフォワード方式は，通信が不可能な状態である時には一旦移動端末内にデータを蓄積し，通信が可能な状態である時にデータを転送する方式である[1]．

\section{従来手法}
DTNの研究として代表的な手法がEpidemic Routingである．また，網資源の管理やデータ到達率向上といった効率的な手法として，Spray And WaitやMaxProp，ProPHET等が存在する．以下にそれら手法の動作を示す．

\subsection{Epidemic Routing}
蓄積運搬形転送に基づく最も初期に提案された手法に，感染形中継転送方式であるEpidemic Routingと呼ばれる手法が存在する．メッセージを保持する端末が他の端末と接触をすることで通信を行い，複製メッセージを拡散させながら網内の末端までメッセージを届けることを可能にし，いずれかのメッセージが宛先端末に到達する．この手法は，網資源がある場合には，あらゆる方式の中で最も優れた遅延性能を示す[1]．

しかし，問題点として，受信端末は複製メッセージをさらに複製するため，網資源を最も消費してしまう欠点がある．よって，拡散させることに重きを置いているため，効率の良いルーティングとは言い難い．Epidemic Routingのフローを図1に示す．

\begin{figure}[h]
	\centering
	\includegraphics[width=100mm]{figures/Routing_method/EpidemicRouting_method.png}
	\caption[]{\it{Epidemic Routing}}
	\label{EpidemicRouting}
\end{figure}

\newpage

\subsection{Recovery Scheme（回復手法）}
Epidemic Routingでは，メッセージが宛先に到達した後，メッセージの複製により網内に到達したメッセージが残存してしまう可能性がある．そのためにRecovery Schemeが提案された．この手法では，メッセージが到達した宛先ノードが，到達した事を知らせるためにメッセージのIDを載せたAnti-Paketを生成する．これにより，Anti-Paketを受信したノードは，該当するメッセージを削除することで，到達したメッセージの複製を抑制する[6]．Recovery Schemeのフローを図1と同様に示す．

\begin{figure}[h]
	\centering
	\includegraphics[width=100mm]{figures/Routing_method/RecoveryScheme_method.png}
	\caption[]{\it{Recovery Scheme}}
	\label{RecoveryScheme}
\end{figure}

\subsection{Spray And Wait}
Spray And Waitは，メッセージ毎に複製回数が静的に設定され，メッセージを複製する度に複製回数が半分に更新される．メッセージは，Spray段階とWait段階の2つに段階を経て転送される[6]．生成元ノードではある整数Lが与えられ，メッセージの複製はそれぞれForward tokenと呼ばれる整数値nを保持する．生成元ノードではn=Lとなり，転送される度にnが半減し，n=1となった時にWait段階へ移行する．Wait段階では，メッセージの複製は行われず，直接，宛先ノードに接触した時のみメッセージを転送する[7]．複製回数が多すぎるとメッセージの削除が発生し，少なすぎると宛先に到達しない場合がある．

問題点として，ネットワークの大きさやノード数の変化に応じて適切な最大生成数を設定することは困難であるということが挙げられる[8]．Spray And Waitのフローを図1，2と同様に示す．

\begin{figure}[h]
	\centering
	\includegraphics[width=100mm]{figures/Routing_method/SprayAndWait_method.png}
	\caption[]{\it{Spray And Wait}}
	\label{SprayAndWait}
\end{figure}

\newpage

\subsection{Max Prop}
Max Propは，各ノードが保持しているメッセージに優先度を付け，他ノードと接触時に優先度の高いメッセージから順に複製メッセージを送信し，バッファの容量が不足した時に優先度の低いメッセージから順に破棄する手法である[7]．MaxPropのフローを図1，2，3と同様に示す．

\begin{figure}[h]
	\centering
	\includegraphics[width=100mm]{figures/Routing_method/MaxProp_method.png}
	\caption[]{\it{MaxProp}}
	\label{MaxProp}
\end{figure}

%%=============第３章=============
\chapter{従来手法の問題点と本研究の問題の定式化}
\section{従来手法(EpidemicRouting)の問題点}
先述の通り，従来手法であるEpidemicRoutingには，最ももう資源を消費する手法であるという問題点がある．そのため，具体的に以下のようなことが起こると考えられる．
\begin{quote}
\begin{itemize}
\item TTLによるメッセージのタイムアウト
\item バッファ溢れ等によるメッセージ削除
\end{itemize}
\end{quote}
これらにより，届けられる可能性の高いメッセージまでもが削除されてしまっているのではないかと考えられる．

\chapter{提案手法}
\section{Priority Message Routing}
先述の問題点から，届けられる可能性の高いメッセージが，バッファから削除されないように改良を行い，この手法をPriorityMessageRoutingと呼ぶ．
Priority Message Routing（以下，PMRouting）とは，端末がメッセージに優先度を設け，他ノードと接触したらそのノードのすれ違ったノード履歴より，自身の保有するメッセージの宛先と同一のメッセージを探す．存在した時に，そのメッセージの優先度を向上させ，バッファ内に存在できる時間をコントロールする．優先度の向上したメッセージに対しTTL（メッセージ有効時間）を変更することで，「データ到達率」，「メッセージ平均遅延時間」，「メッセージ削除数」の改善を図る手法である．基本的なメッセージの転送は感染形中継転送方式であり，優先度を設けることから，Epidemic Routingを拡張したものとなる．以降，全てのメッセージに備わっているTTLを「ベースTTL」，優先度の向上したメッセージのTTLを「優先TTL」と呼ぶ．

\section{PMRoutingの構成とアルゴリズム}
PMRoutingでは，始めにEpidemic Routingの環境を用意する．そこで，各メッセージに優先度を設けるためのメソッドを追加する．次に各ノードのすれ違ったノードを格納するためのリストを追加し，自身の保有するメッセージの宛先と比較する．最後に，自身の保有するメッセージの宛先が他ノードのすれ違ったノードのリストに存在していれば，その宛先メッセージの優先度を向上させ，TTLをコントールする．PMRoutingのフローを図\ref{PriorityMessageRouting}，アルゴリズムのフローチャート及びその擬似言語を図\ref{PriorityMessageRoutingalgo}及びアルゴリズム1に示す．

\begin{figure}[h]
	\centering
	\includegraphics[width=100mm]{figures/Routing_method/PriorityMessageRouting_method.png}
	\caption[]{\it{Priority Message Routing}}
	\label{PriorityMessageRouting}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=100mm]{figures/Routing_method/PriorityMessageRouting_algorithm.png}
	\caption[]{\it{Priority Message Routing\_アルゴリズム（フローチャート）}}
	\label{PriorityMessageRoutingalgo}
\end{figure}

\makeatletter
    \renewcommand{\ALG@name}{アルゴリズム}
    \makeatother
    \begin{algorithm}[tb]
    \caption{\it{Priority Message Routing\_アルゴリズム（擬似言語）}}
    \begin{algorithmic}[1]

    \For {Message型 myMsg：myMessages}
    　　　\State DTNHost型：$myDestination \gets myMsg$から宛先を取得
            \If {相手のすれ違いリスト∋自身の保有メッセージの宛先}
            　　\State $現在の優先度 \gets 現在の優先度$+1
          　　　\State $ベースTTL \gets 優先TTL$
            \EndIf
    \EndFor
    \end{algorithmic}
    \end{algorithm}

%%=============第４章=============
\chapter{評価}
\section{評価方法}
計算機シミュレーションにより，「データ到達率」，「メッセージ平均遅延時間」，「メッセージ削除数」を評価尺度として提案方式の性能を検証する．また，従来手法（Epidemic Routing及びMax Prop）と提案手法の性能を比較し，提案手法の実用性を検証する．従来研究における最も効率的な手法であるMax Propを比較対象とすることで，提案手法がどの程度の実用性があるのかを把握する．マップ形状は，疎密状態であるdefault\_map及び過密状態であるstar\_mapである．

\section{実験環境}
本研究では，The ONEシミュレータ（The Opportunistic Network Environment Simulator）[5]を用いて実験を行う．The ONEシミュレータは，DTNの評価実験をするために作成されたフリーのネットワークシミュレータである．任意のルーティングやモビリティパターンを導入することができる．時間の遷移方式はタイムステップ型であり，標準では0.1秒毎に遷移する．また，通信可能距離と通信速度のみを考慮し，パケットのロスト，建物，電波干渉等による通信範囲の削減，保有メッセージの把握等の細かい部分は考慮していない[5]．このシミュレータではバンドル層以上のみでシミュレーションを行っているため，トランスポート層以下に関わる電波の輻輳や衝突等については，パラメータで妥当な値を設定しなければならない[9]．

\section{条件とシミュレーションパラメータ}
本研究を行う上での条件を以下に示す．
\begin{quote}
 \begin{itemize}
  \item デフォルトマップ（初期状態のThe ONEシミュレータに搭載されている）及びスターマップを用いる．
  \item ノードは，歩行者と車に割り振る．
  \item 歩行者には，歩くスピードが遅い人と速い人がいることを想定し，それぞれ1.8km/hから5.4km/hとする．
  \item 車は，法定速度の多い40km/hから60km/hを想定する．
  \item 結果は，固定経路を進むシミュレーション結果を示す．
  \item 移動モデルは，各ノードが目的地を定めて最短経路で動くと仮定し，ShortestPathMapBasedMovementを用いる．
 \end{itemize}
\end{quote}
本研究を行うためのシミュレーションパラメータを表\ref{simpara}に示す．

\begin{table}[h]
    \begin{center}
      \caption[]{シミュレーションパラメータ}
      \label{simpara}
      \begin{tabular}{|c|c|}
        \hline
        移動モデル & ShortestPathMapBasedMovement\\
        \hline
        シミュレーション時間 & 43200秒\\
        \hline
        試行回数 & 1回\\
        \hline
        ノード数 & 100，200，300\\
        \hline
        ベースTTL & 300，720 [分]\\
        \hline
        優先TTL & 各ノード数によって変更\\
        \hline
        ノードリスト
        格納数 & 20 [個]\\
        \hline
        ノードの移動速度（人） & 1.8，5.4 [km/h]\\
        \hline
        ノードの移動速度（車） & 39.96，59.94 [km/h]\\
        \hline
        発行メッセージ数 & 1460\\
        \hline
        通信速度 & 250[kbps]\\
        \hline
        通信可能距離 & 10 [m]\\
        \hline
        端末バッファ容量 & 50 [MBytes]\\
        \hline
      \end{tabular}
    \end{center}
\end{table}
%%図default_map
%%図star_map

\section{優先TTLの設定について}
図\ref{priorityTTL}に示すように，優先TTLに対するデータ到達率は，環境ごとにある値で最大となることが確認できており，ベースTTLやノード数，マップ等のそれぞれの環境で適切な値をとる必要がある．本研究では，各環境ごとに適切な優先TTLの記録をとっている．
\begin{figure}[H]
	\centering
	\includegraphics[width=80mm]{figures/priority_TTL.png}
	\caption[]{\it{優先TTLに対するデータ到達率}}
	\label{priorityTTL}
\end{figure}
%%=============第４章=============
\chapter{実験結果}

%%=============デフォルトマップ_TTL300=============
\section{疎密状態マップ TTL=300}
ベースTTL300における，ノード数を100，200，300に設定したときの，「データ到達率」，「メッセージ平均遅延時間」，「メッセージ削除数」の結果を，表\ref{somituTtl300deliveryprob}，表\ref{somituTtl300latencyavg}，表\ref{somituTtl300dropped}にそれぞれ示す．ここで，MaxPropの削除数については，ベースTTLによるタイムアウトやバッファ溢れ等によるメッセージの削除(dropped)だけでなく，MaxPropのアルゴリズムによるメッセージの削除(removed)についての両方を記録している．

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/default_TTL300/default_TTL300_toutaturitu.png}
\caption[]{\it{データ到達率(疎密状態マップ TTL300)}}
\label{somituttl300deliveryprobgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{データ到達率(疎密状態マップ TTL300)}}
      \label{somituTtl300deliveryprob}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&0.3523&0.5326&0.6001\\
\hline
MaxPropRouting&0.4695&0.8003&0.8934\\
\hline
PriorityMessageRouting&0.3948&0.5347&0.6282\\
\hline
      \end{tabular}
    \end{center}
\end{table}

\newpage

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/default_TTL300/default_TTL300_tienjikan.png}
\caption[]{\it{メッセージ平均遅延時間(疎密状態マップ TTL300)}}
\label{somituttl300latencyavggraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{メッセージ平均遅延時間(疎密状態マップ TTL300)}}
      \label{somituTtl300latencyavg}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&9063.5916&9473.171&8910.7454\\
\hline
MaxPropRouting&8808.0453&6908.4267&4511.4366\\
\hline
PriorityMessageRouting&11181.6049&5722.8538&7707.9552\\
\hline
      \end{tabular}
    \end{center}
\end{table}

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/default_TTL300/default_TTL300_sakuzyosu.png}
\caption[]{\it{メッセージ削除数(疎密状態マップ TTL300)}}
\label{somituttl300droppedgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{メッセージ削除数(疎密状態マップ TTL300)}}
      \label{somituTtl300dropped}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&9562&39899&92280\\
\hline
MaxPropRouting&685,re5851&436,re38112&re86815\\
\hline
PriorityMessageRouting&8722&40988&93206\\
\hline
      \end{tabular}
    \end{center}
\end{table}

\subsection{データ到達率}
図\ref{somituttl300deliveryprobgraph}に示すように，データ到達率は，適切な優先TTLを設定した上で比較を行うと，PMRoutingのデータ到達率はEpidemic Roitingより僅かに良い結果が得られた．これは，優先度の高いメッセージの削除を防ぎ，宛先に届く可能性の高いメッセージを保持し続けることができていたためであると考える．一方で，MaxPropと比較すると，データ到達率は下回る結果となった．\\
%%図ttl300deliveryprob
\subsection{メッセージ平均遅延時間}
図\ref{somituttl300latencyavggraph}に示すように，メッセージ平均遅延時間は，ノード数が200の場合において，PMRoutingの平均遅延時間は最も小さくなった．また，どのノード数においてもEpidemicRoutingと比較した場合に良い結果が得られた．これは，到達率と同様に，EpidemicRoutingの場合は，届く可能性のあるメッセージをTTLによるタイムアウトや，バッファ溢れ等により失ってしまっているが，PMRoutingでは優先メッセージを保持し，網内に流布しやすい状態にあるため，結果として遅延時間がEpidemicRoutingよりも改善されたと考える．一方で，MaxPropと比較すると，メッセージ平均遅延時間は下回る結果となった．\\
%%図ttl300latencyavg

\subsection{メッセージ削除数}
図\ref{somituttl300droppedgraph}に示すように，ノード数が上がるごとにメッセージ削除数が上がり，EpidemicRoutingよりもわずかに高い削除数となった，ここでメッセージの削除数とは，ベースTTL及び優先TTLによるタイムアウトやバッファ溢れ等によるメッセージの削除(dropped)となっており，PMRoutingは優先TTLの制御によってメッセージの削除を行っている．また，MaxPropはバッファ溢れが起きる際，ベースTTLに関わらず，優先度の低いメッセージを削除(removed)し，新しいメッセージを取得するという手法によって，バッファ溢れを防いでいるため，ここでのメッセージ削除数は限りなく小さく，代わりに設定条件下での意図的なメッセージ削除数が多くなっている．\\
%%図ttl300dropped
\subsection{疎密状態マップ，ベースTTL300における優先TTL}
表\ref{priorityTTL_somitsu300}に示すように，ノード数が100の場合を除き，優先TTLはベースTTLよりも低い値に設定することでより効果が得られた．
\begin{table}[H]
	\begin{center}
			 \caption[]{\it{優先TTL(疎密状態マップ ベースTTL300)}}
			 \label{priorityTTL_somitsu300}
			 \begin{tabular}{|c|c|}
 \hline
 ノード数&優先TTL[\it{min}]\\
 \hline
 100&410\\
 \hline
 200&290\\
 \hline
 300&230\\
 \hline
			 \end{tabular}
		 \end{center}
 \end{table}
\newpage

%%=============デフォルトマップ_TTL720=============
\section{疎密状態マップ ベースTTL=720}
ベースTTL720における，ノード数を100，200，300に設定したときの，「データ到達率」，「メッセージ平均遅延時間」，「メッセージ削除数」の結果を，表\ref{somituTtl720deliveryprob}，表\ref{somituTtl720latencyavg}，表\ref{somituTtl720dropped}にそれぞれ示す．

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/default_TTL720/default_TTL720_toutaturitu.png}
\caption[]{\it{データ到達率(疎密状態マップ ベースTTL720)}}
\label{somituttl720deliveryprobgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{データ到達率(疎密状態マップ ベースTTL720)}}
      \label{somituTtl720deliveryprob}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&0.3729&0.4036&0.4204\\
\hline
MaxPropRouting&0.5497&0.8058&0.8927\\
\hline
PriorityMessageRouting&0.3948&0.5347&0.6377\\
\hline
      \end{tabular}
    \end{center}
\end{table}

\newpage

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/default_TTL720/default_TTL720_tienjikan.png}
\caption[]{\it{メッセージ平均遅延時間(疎密状態マップ ベースTTL720)}}
\label{somituttl720latencyavggraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{メッセージ平均遅延時間(疎密状態マップ ベースTTL720)}}
      \label{somituTtl720latencyavg}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&12670.4281&10499.5253&9447.9813\\
\hline
MaxPropRouting&11475.7576&6991.6428&9380.4749\\
\hline
PriorityMessageRouting&11181.6049&9160.6067&8219.5436\\
\hline
      \end{tabular}
    \end{center}
\end{table}

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/default_TTL720/default_TTL720_sakuzyosu.png}
\caption[]{\it{メッセージ削除数(疎密状態マップ ベースTTL720)}}
\label{somituttl720droppedgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{メッセージ削除数(疎密状態マップ ベースTTL720)}}
      \label{somituTtl720dropped}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&5265&33018&83972\\
\hline
MaxPropRouting&70,re7767&4,re38259&re86832\\
\hline
PriorityMessageRouting&8722&39950&92100\\
\hline
      \end{tabular}
    \end{center}
\end{table}

\subsection{データ到達率}
図\ref{somituttl720deliveryprobgraph}に示すように，ベースTTL720における疎密状態マップでは，データ到達率はノード数が増えるに連れて，Epidemic Routingとの差が広がった．これは，メッセージ有効時間であるTTLが長くなったことに加え，宛先に届けることのできるメッセージが多くなったからであると考えられる．また，優先TTLにより一部メッセージがPM Routingによって削除されることで，網内のメッセージ数が削減されたことが起因していると考えられる．結果的に網内のメッセージ数が本来の数より減少し，優先度の高いメッセージが早く削除されることによって，効率よくメッセージが網内を循環していると考えた．しかし，理論上は優先度の向上するメッセージが，優先TTLによる干渉を受ける前に到達しているか，また，優先度が向上した後，優先TTLの時間内で宛先ノードに到達している必要がある．特に，ベースTTLが720の場合，シミュレーション時間と同等の有効時間になるため，メッセージの削除条件がベースTTLによるタイムアウトではなく，バッファ溢れ及び優先TTLのみになってしまう．これらから，ベースTTLが720の場合には，優先TTLの値が小さければ小さいほど優先度の低いメッセージが網内に取り残され，バッファに空きがある限りは到達する可能性の低いメッセージが網内を循環することになる．

\subsection{メッセージ平均遅延時間}
図\ref{somituttl720latencyavggraph}に示すように，メッセージ平均遅延時間では，Epidemic Routingとの結果は約1200秒から1500秒前後短くなった．全体的にはノード数が多くなるに連れて減少した．Epidemic Routingよりも良い結果が見られたことにより，優先度の向上したメッセージが削除される前に，宛先に無事辿り着いたことを意味している．提案手法では，主に優先TTLの有無がEpidemic Routingとの差に繋がるため，優先TTLの有効性が確認できた．ノード数が多くなるに連れてメッセージ平均遅延時間が減少した原因は，データ到達率が向上したことにより1つあたりのメッセージが早く宛先に到達したからだと考える．

\subsection{メッセージ削除数}
図\ref{somituttl720droppedgraph}に示すように，メッセージ削除数では，ノード数が多くなるに連れて削除数が多くなった．これは，ノードが増える度に複製メッセージが量産され，1ノードあたりのバッファ溢れ及び優先TTLによるメッセージの削除が多くなったからだと考える．

\subsection{疎密状態マップ，ベースTTL720における優先TTL}
図\ref{priorityTTL_somitsu720}に示すように，TTL300における優先TTLと同様の結果が得られた．
\begin{table}[H]
	\begin{center}
			 \caption[]{\it{優先TTL(疎密状態マップ ベースTTL720)}}
			 \label{priorityTTL_somitsu720}
			 \begin{tabular}{|c|c|}
 \hline
 ノード数&優先TTL[\it{min}]\\
 \hline
 100&410\\
 \hline
 200&290\\
 \hline
 300&260\\
 \hline
			 \end{tabular}
		 \end{center}
 \end{table}

%%=============スターマップ_TTL300=============
\section{過密状態マップ ベースTTL=300}
ベースTTL300における，ノード数を100，200，300に設定したときの，「データ到達率」，「メッセージ平均遅延時間」，「メッセージ削除数」の結果を，表\ref{kamituttl300deliveryprob}，表\ref{kamituttl300latencyavg}，表\ref{kamituttl300dropped}にそれぞれ示す．

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/star_TTL300/star_TTL300_toutaturitu.png}
\caption[]{\it{データ到達率(過密状態マップ ベースTTL300)}}
\label{kamituttl300deliveryprobgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{データ到達率(過密状態マップ ベースTTL300)}}
      \label{kamituttl300deliveryprob}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&0.6854&0.6184&0.6179\\
\hline
MaxPropRouting&0.974&0.9794&0.9836\\
\hline
PriorityMessageRouting&0.8732&0.9176&0.907\\
\hline
      \end{tabular}
    \end{center}
\end{table}

\newpage

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/star_TTL300/star_TTL300_tienjikan.png}
\caption[]{\it{メッセージ平均遅延時間(過密状態マップ ベースTTL300)}}
\label{kamituttl300latencyavggraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{メッセージ平均遅延時間(過密状態マップ ベースTTL300)}}
      \label{kamituttl300latencyavg}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&3848.7533&3538.5382&3494.9347\\
\hline
MaxPropRouting&1268.0588&891.8756&806.9937\\
\hline
PriorityMessageRouting&2465.137&2156.8358&2158.276\\
\hline
      \end{tabular}
    \end{center}
\end{table}

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/star_TTL300/star_TTL300_sakuzyosu.png}
\caption[]{\it{メッセージ削除数(過密状態マップ ベースTTL300)}}
\label{kamituttl300droppedgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{メッセージ削除数(過密状態マップ ベースTTL300)}}
      \label{kamituttl300dropped}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&89119&265671&499754\\
\hline
MaxPropRouting&re65218&re150311&re243119\\
\hline
PriorityMessageRouting&87071&252813&482528\\
\hline
      \end{tabular}
    \end{center}
\end{table}

\subsection{データ到達率}
図\ref{kamituttl300deliveryprobgraph}に示すように，ベースTTL300における過密状態マップでは，データ到達率はEpidemic Routingが約6から7割に対し，PM Routingでは約9割と高水準なデータが得られた．これは，疎密状態マップと同様に，優先度が向上した後，優先TTLの時間内で宛先ノードに到達したからであると考える．また，スターマップではデフォルトマップよりもノード数による変化は大きくなかった．しかし，過密状態であるスターマップにおいても約20\%高いことが確認できたため，マップによる変化を問わず，PM Routingの有効性が立証できた．

\subsection{メッセージ平均遅延時間}
図\ref{kamituttl300latencyavggraph}に示すように，メッセージ平均遅延時間では，ノード数が300の時点で約1.4秒増加した．当初は，疎密状態であるデフォルトマップと同様に，ノード数の変化によって減少すると考えていた．しかし，結果がそうでなかった理由として考えられるのは，スターマップにおける人間及び車と例えたノードの初期配置によるものだと考える．

\subsection{メッセージ削除数}
図\ref{kamituttl300droppedgraph}に示すように，メッセージ削除数では，デフォルトマップよりも約5から8倍遅延していた．この結果においても，原因は過密によるノードの接触により複製メッセージが量産され，バッファ溢れ及び優先TTLによるメッセージの削除が多くなったからだと考える．

\subsection{過密状態マップ，ベースTTL300における優先TTL}
図\ref{priorityTTL_kamitsu300}に示すように，先程までの疎密状態マップと比較すると，優先TTLはより低い値で効果が得られた．過密状態マップは接触と複製メッセージの増加により，バッファ内のメッセージがあふれやすい環境などで効果が得られやすいのではないかと考える．
\begin{table}[H]
	\begin{center}
			 \caption[]{\it{優先TTL(過密状態マップ ベースTTL300)}}
			 \label{priorityTTL_kamitsu300}
			 \begin{tabular}{|c|c|}
 \hline
 ノード数&優先TTL[\it{min}]\\
 \hline
 100&90\\
 \hline
 200&80\\
 \hline
 300&80\\
 \hline
			 \end{tabular}
		 \end{center}
 \end{table}
\newpage

%%=============スターマップ_TTL720=============
\section{過密状態マップ ベースTTL=720}
ベースTTL720における，ノード数を100，200，300に設定したときの，「データ到達率」，「メッセージ平均遅延時間」，「メッセージ削除数」の結果を，表\ref{kamituttl720deliveryprob}，表\ref{kamituttl720latencyavg}，表\ref{kamituttl720dropped}にそれぞれ示す．

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/star_TTL720/star_TTL720_toutaturitu.png}
\caption[]{\it{データ到達率(過密状態マップ ベースTTL720)}}
\label{kamituttl720deliveryprobgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{データ到達率(過密状態マップ ベースTTL720)}}
      \label{kamituttl720deliveryprob}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&200&300\\
\hline
EpidemicRouting&0.5798&0.5216&0.5038\\
\hline
MaxPropRouting&0.9726&0.9808&0.9843\\
\hline
PriorityMessageRouting&0.8732&0.9073&0.8859\\
\hline
      \end{tabular}
    \end{center}
\end{table}

\newpage

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/star_TTL720/star_TTL720_tienjikan.png}
\caption[]{\it{メッセージ平均遅延時間(過密状態マップ ベースTTL720)}}
\label{kamituttl720latencyavggraph}
\end{figure}

\begin{table}[H]
	\begin{center}
      \caption[]{\it{メッセージ平均遅延時間(過密状態マップ ベースTTL720)}}
      \label{kamituttl720latencyavg}
      \begin{tabular}{|c|c|c|c|}
				\hline
				&100&200&300\\
				\hline
				EpidemicRouting&3608.918&3281.6612&3291.3509\\
				\hline
				MaxPropRouting&1262.1765&105.1085&802.9019\\
				\hline
				PriorityMessageRouting&2465.137&2152.6198&2187.0545\\
				\hline
			\end{tabular}
			\end{center}
\end{table}

%%==============================================
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{figures/star_TTL720/star_TTL720_sakuzyosu.png}
\caption[]{\it{メッセージ削除数(過密状態マップ ベースTTL720)}}
\label{kamituttl720droppedgraph}
\end{figure}

\begin{table}[H]
 \begin{center}
      \caption[]{\it{メッセージ削除数(過密状態マップ ベースTTL720)}}
      \label{kamituttl720dropped}
      \begin{tabular}{|c|c|c|c|}
\hline
&100&300&500\\
\hline
EpidemicRouting&88977&267876&506915\\
\hline
MaxPropRouting&re64749&re150357&re242869\\
\hline
PriorityMessageRouting&87071&254976&485834\\
\hline
      \end{tabular}
    \end{center}
\end{table}
\subsection{データ到達率}
図\ref{kamituttl720deliveryprobgraph}に示すように，ベースTTL300の時と同様に，EpidemicRoutingの結果を上回り，また，ノード数の増加によりEpidemicRoutingとの差も大きくなった．

\subsection{メッセージ平均遅延時間}
図\ref{kamituttl720latencyavggraph}に示すように，ノード数が200の場合において，PMRoutingの平均時間は最も短くなった．また，いずれのノード数においても，EpidemicRoutingと比較するとより良い結果が得られていることが分かる．

\subsection{メッセージ削除数}
図\ref{kamituttl720droppedgraph}に示すように，PMRoutingとEpidemicRoutingのメッセージ削除数を比較すると，PMRoutingのメッセージ削除数の方が，僅かに小さくなった．マップが過密であるが故に，ノードのリストの更新が高い頻度で行われたことにより，メッセージの優先度更新も同様の頻度で行われ，その結果，保持状態になっているメッセージが多く出てきたことで，EpidemicRoutingよりも削除数が少なくなったのではないかと考える．また，ベースTTL300と比較した場合において，結果には大きな違いはなかったため，この過密マップにおいては他の条件でも同様の結果が得られるのではないかと考える．

\subsection{過密状態マップ，ベースTTL720における優先TTL}
図\ref{priorityTTL_kamitsu720}に示すように，TTL300と同様に，疎密状態マップよりも低い優先度で効果が得られた．
\begin{table}[H]
	\begin{center}
			 \caption[]{\it{優先TTL(過密状態マップ TTL720)}}
			 \label{priorityTTL_kamitsu720}
			 \begin{tabular}{|c|c|}
 \hline
 ノード数&優先TTL[\it{min}]\\
 \hline
 100&90\\
 \hline
 200&80\\
 \hline
 300&80\\
 \hline
			 \end{tabular}
		 \end{center}
 \end{table}
\newpage
\chapter{結論}
本研究では，EpidemicRoutingのTTLによるタイムアウト等により，本来届くはずのメッセージまでも削除されてしまっているという問題点に着目した．提案手法であるPriority Message Routingでは，遭遇したノードのリストをもとに優先度を設定し，優先度の高いメッセージを保持し続ける方式を提案した．

また，提案手法をThe ONEシミュレータにより，疎密状態及び過密状態のマップを使用した，ベースTTL及び優先TTL，ノード数別のシミュレーションを行った．それらの結果を従来手法である
Epidemic Routingと比較評価を行った結果，以下のような結論が得られた．

\begin{quote}
 \begin{itemize}
  \item ノード数が増加するに連れて，複製メッセージも増加するため，網内のメッセージを効率的に削除しなければならない．
  \item 各マップにおいて，データ到達率及びメッセージ遅延時間の結果に反し，メッセージ削除数が増加するといったトレードオフの関係性を確認できた．
  \item バッファ内のメッセージがあふれやすい環境などで，優先TTLが短いほどデータ到達率が向上した．
  \item データ到達率について，従来のEpidemic Routingよりも大きい結果となり，MaxPropの到達率には届かない結果となった．
 \end{itemize}
\end{quote}

疎密状態であるデフォルトマップのベースTTLが300かつノード数が100個のメッセージ平均遅延時間を除く全ての項目において，当初の研究目標である「データ到達率」，「メッセージ平均遅延時間」「メッセージ削除数」を達成した．

本実験における提案手法を現実の災害時で扱うためには，各地域のマップ形状や端末保有台数等を考慮しなければならない．以上から，災害地域の現状を想定することで，この提案手法は最大限に効果を発揮すると考えられる．

%%======================================================================================================================
%% ここまで本文 ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
%%======================================================================================================================

%% 謝辞
\clearpage
\fancyhead[L]{}\fancyhead[R]{}
\renewcommand{\headrulewidth}{0truemm}
\section*{謝辞}
本研究を遂行し，卒業論文をまとめるにあたって，ご指導ならびにご助言して頂き，研究室活動全般にわたってお世話になりました菅原真司教授に感謝致します．

%%----------------------------------------------------------------------------------------------------------------------
%% 参考文献
\clearpage
\nocite{*}
\bibliographystyle{icsthesis}
\fancyhead[L]{\nouppercase{\small\leftmark}}\fancyhead[R]{}
\renewcommand{\headrulewidth}{0.3truemm}
\bibliography{thesis}

%%----------------------------------------------------------------------------------------------------------------------
%% 付録： 不要なら，最後の \end{document} を残して，これ以降の行を消す．
%%
\clearpage
\fancyhead[L]{\nouppercase{\small\leftmark}}
\fancyhead[R]{\nouppercase{\small\rightmark}}
\fancyfoot[C]{--\ \thepage\ --}
\renewcommand{\headrulewidth}{0.3truemm}
\appendix
\chapter{マップについて}
今回の実験では，シミュレータに搭載されていたヘルシンキのマップに加えて，自作の完全グラフのマップでの実験を行った．研究開始当初は参考文献に倣い，他の実在するマップでの実験を行う予定であったが，マップ導入時の問題を解決することができなかったため，断念した．\\\\
ここでは，マップの導入に関して行った手順について記す．
%ここは「付録章」である．\textsf{\yen appendix}以降に，\textsf{\yen chapter\{見出し文字列\}}と書けば，
%「付録章見出し」が設定される．
%「章見出し」と同じ文字サイズ，同じ上下余白である．

\section{osmファイルからwktファイルへの変換}



\subsection{osmファイル}
osm ファイルとは，オープンストリートマップという自由に利用でき，共同編集機能のある世界地図を作成する共同作業プロジェクト[9]にてエクスポートすることができるファイル形式である．osmファイルの状態では，TheONEシミュレータで用いることができない．
\subsection{wktファイル}
wktファイルとは，地理情報をテキスト形式で表現するファイル形式である．TheONEシミュレータで読み込めるマップの形式はwktファイルのみであるため，osmファイルは何らかの形でwktファイルに変更する必要がある．
\section{osmファイルとwktファイル}

\subsection{OpenJUMPを用いたosmファイルからwktファイルへの変換}
参考文献[10]に倣いOpenJUMPというソフトを用いてosmファイルからwktファイルへの変換を行う．OpenJUMP とは，ユーザが地理データを表示したり編集したりすることが出るGIS(地理情報システム)である．osmファイルをOpenJUMPで開くと図\ref{OpenJUMP}のようになり，ここから様々なノード等の編集ができる．しかし，この方法は動作環境によってはOpenJUMP上でosmファイルを開くことができないという現象が確認できた．
\begin{figure}[H]
	\centering
	\includegraphics[width=100mm]{figures/OpenJUMP.png}
\caption[]{\it{osmファイルをOpenJUMPで開いた様子}}
\label{OpenJUMP}
\end{figure}
\subsection{QGISを用いたosmファイルからwktファイルへの変換}
上記の問題を解決するため，QGISという別のソフトを用いる[10]．QGIS とはGNU General Public License で提供されている，OpenJUMP と同じGIS(地理情報システム) であり，OpenJUMPと比べて多くの機能が備えられている．osmファイルに対応しており，このソフトを用いてosmファイルをshpファイルに変換する．osmファイルを別のファイル形式に変換後，そのファイルを改めてOpenJUMP上で開くことで，wktファイルへの変換を行った．
\section{マップ導入時の問題}
上記の二つのどちらの場合でも，OpenJUMPにファイルを読み込んだ際，マップの縮尺が極端に小さくなってしまった．TheONEシミュレータに導入した際も，極端に小さくなった状態で実行されてしまうため，正しい結果が得られなくなってしまった．この問題を解決することができなかったため，実在するマップでの実験を断念した．

\newpage

%%=============プログラム=============
\section{プログラム}
\lstset{
    frame=single,
    numbers=left,
    tabsize=2
}
\subsection{PriorityMessageRouter.java}
\begin{framed}
\begin{verbatim}
package routing;

import core.Connection;
import core.DTNHost;
import core.Message;
import core.Settings;

import gui.EventLogPanel;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

public class PriorityMessageRouter extends ActiveRouter {
    private static final int MAX_QUEUE_SIZE = 20; // キューの最大サイズ
    private LinkedList<Integer> nodeQueue; // ノード番号を格納するキュー
    private Timer timer; // タイマー

    /**
     * @param s
     **/
    public PriorityMessageRouter(Settings s) {
        super(s);
        nodeQueue = new LinkedList<>();
        timer = new Timer();
        startQueueCleanupTask();
    }

    public LinkedList<Integer> getNodeQueue() {
        return this.nodeQueue;
    }

    /**
     * @param r
     **/
    protected PriorityMessageRouter(PriorityMessageRouter r) {
        super(r);
        this.nodeQueue = new LinkedList<>(r.nodeQueue);
        this.timer = new Timer();
        startQueueCleanupTask();
    }

    private void startQueueCleanupTask() {//常に最新のすれ違った履歴にする
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                cleanUpQueue();
            }
        }, 0, 5 * 60 * 1000); // 5分ごとにノードリストをクリア
    }

    private void cleanUpQueue() {
        if (nodeQueue.size() > MAX_QUEUE_SIZE) {
            nodeQueue.removeFirst(); // キューの先頭（古い要素）を削除
        }
    }

    @Override
    public void update() {
        super.update();
        if (isTransferring() || !canStartTransfer()) {
            return;
        }

        if (exchangeDeliverableMessages() != null) {
            return;
        }

        this.tryAllMessagesToAllConnections();
    }

    @Override
    public PriorityMessageRouter replicate() {
        return new PriorityMessageRouter(this);
    }

    public void changedConnection(Connection con) {
        super.changedConnection(con);
        
        // 新しく接続されたノードのIDを取得
        if (con.isUp()) {
            DTNHost otherHost = con.getOtherNode(getHost());
            int otherAddress = otherHost.getAddress();
            
            System.out.println("-----");
            
            // ノードIDをキューに追加
            if (!nodeQueue.contains(otherAddress)) {
                if (nodeQueue.size() >= MAX_QUEUE_SIZE) {
                    nodeQueue.removeFirst(); // キューの先頭を削除
                }
                nodeQueue.addLast(otherAddress); // 新しいノードIDを追加
                System.out.println("着目ノード:" + getHost());
                System.out.println("追加されたノード:" + otherAddress + ", 
                追加後の" + getHost() + "のキュー: " + nodeQueue);
            }
            PriorityMessageRouter otherRouter = 
            (PriorityMessageRouter) otherHost.getRouter();
            System.out.println("相手ノード(ノードID:" + otherAddress + 
            ")のノードリスト: " + otherRouter.getNodeQueue());
      
            Collection<Message> myMessages = 
            getHost().getMessageCollection();
            
            System.out.println("保有メッセージ：" + myMessages);

            for (Message myMsg : myMessages) {
                DTNHost myDestination = myMsg.getTo();
                if (otherRouter.getNodeQueue().contains
                (myDestination.getAddress())) {
                    System.out.println("遭遇ノード:" + otherAddress + 
                    "はメッセージID:" + myMsg.getId() + "の宛先" + 
                    myDestination.getAddress() + "とすれ違ってます． ");
                    System.out.print("メッセージ更新前: [");
                    for (Message msg : myMessages) {
                        System.out.print("ID:" + msg.getId() + "優先度:" + 
                        msg.getPriority() + " [" + msg.getTtl() + "] " + 
                        ", ");
                    }
                    System.out.println("]");

                    // 同一の宛先が見つかった場合，優先度を+1
                    // メッセージの優先度を上げる（getメソッド）
                    myMsg.setPriority(myMsg.getPriority() + 1);
                    
                    // 優先度が上がったメッセージのTTLを変更
                    // 無限に生存させる場合は「-1」にする
                    myMsg.setTtl(200);

                    System.out.print("メッセージ更新後: [");
                    for (Message msg : myMessages) {
                        System.out.print("ID:" + msg.getId() + "優先度:" + 
                        msg.getPriority() + " [" + msg.getTtl() + "] " + 
                        ", ");
                    }
                    System.out.println("]");  

                    // メッセージの優先度を元に戻す
                    （どのメッセージの優先度が更新されたかを見やすくするため）  
                    myMsg.setPriority(myMsg.getPriority() - 1);
                }
            }

            System.out.println("-----");
        }
    }
}
\end{verbatim}
\end{framed}

\subsection{セッティング（default\_map及びstar\_map）}
\begin{framed}
\begin{verbatim}
#
# Default settings for the simulation
#

## Scenario settings
Scenario.name = default_scenario
Scenario.simulateConnections = true
Scenario.updateInterval = 0.1
# 43200s == 12h
Scenario.endTime = 43200


## Interface-specific settings:
# type : which interface class the interface belongs to
# For different types, the sub-parameters are interface-specific
# For SimpleBroadcastInterface, the parameters are:
# transmitSpeed : transmit speed of the interface (bytes per second) 
# transmitRange : range of the interface (meters)

# "Bluetooth" interface for all nodes
btInterface.type = SimpleBroadcastInterface
# Transmit speed of 2 Mbps = 250kBps
btInterface.transmitSpeed = 250k
btInterface.transmitRange = 10



# Define 6 different node groups
Scenario.nrofHostGroups = 2 #歩行者と車の2種類

## Group-specific settings:
# groupID : Group's identifier. Used as the prefix of host names
# nrofHosts: number of hosts in the group
# movementModel: movement model of the hosts 
(valid class name from movement package)
# waitTime: minimum and maximum wait times 
(seconds) after reaching destination
# speed: minimum and maximum speeds (m/s) when moving on a path
# bufferSize: size of the message buffer (bytes)
# router: router used to route messages 
(valid class name from routing package)
# activeTimes: Time intervals when the nodes in the group are active 
(start1, end1, start2, end2, ...)
# msgTtl : TTL (minutes) of the messages created by this host group, 
default=infinite

## Group and movement model specific settings
# pois: Points Of Interest indexes and probabilities 
(poiIndex1, poiProb1, poiIndex2, poiProb2, ... )
#       for ShortestPathMapBasedMovement
# okMaps : which map nodes are OK for the group (map file indexes), 
default=all 
#          for all MapBasedMovent models
# routeFile: route's file path - for MapRouteMovement
# routeType: route's type - for MapRouteMovement


# Common settings for all groups
Group.movementModel = ShortestPathMapBasedMovement
Group.router = EpidemicRouter
Group.bufferSize = 50M
Group.waitTime = 0, 120
# All nodes have the bluetooth interface
Group.nrofInterfaces = 1
Group.interface1 = btInterface
# Walking speeds
Group.speed = 0.5, 1.5 #歩行者の速さ
# Message TTL of 300 minutes (5 hours)
Group.msgTtl = 300 #TTLによって変更

Group.nrofHosts = 50 #ノード数によって変更

# group1 (pedestrians) specific settings
Group1.groupID = p

# group2 specific settings
Group2.groupID = c
# cars can drive only on roads
Group2.okMaps = 1
# 10-50 km/h
Group2.speed = 11.1, 16.65 #車の速さ



## Message creation parameters 
# How many event generators
Events.nrof = 1
# Class of the first event generator
Events1.class = MessageEventGenerator
# (following settings are specific for the MessageEventGenerator class)
# Creation interval in seconds (one new message every 25 to 35 seconds)
Events1.interval = 25,35
# Message sizes (500kB - 1MB)
Events1.size = 500k,1M
# range of message source/destination addresses
Events1.hosts = 0,99 #ノード数によって変更
# Message ID prefix
Events1.prefix = M


## Movement model settings
# seed for movement models' pseudo random number generator (default = 0)
MovementModel.rngSeed = 1
# World's size for Movement Models without implicit size 
(width, height; meters)
MovementModel.worldSize = 4500, 3400
# How long time to move hosts in the world before real simulation
MovementModel.warmup = 1000

## Map based movement -movement model specific settings
MapBasedMovement.nrofMapFiles = 4 #star_mapのみの形成時には1にする

MapBasedMovement.mapFile1 = data/roads.wkt #star_map時には該当するwktファイルを挿入
MapBasedMovement.mapFile2 = data/main_roads.wkt #必要に応じて消す
MapBasedMovement.mapFile3 = data/pedestrian_paths.wkt #必要に応じて消す
MapBasedMovement.mapFile4 = data/shops.wkt #必要に応じて消す

## Reports - all report names have to be valid report classes

# how many reports to load
Report.nrofReports = 1
# length of the warm up period (simulated seconds)
Report.warmup = 0
# default directory of reports 
(can be overridden per Report with output setting)
Report.reportDir = reports/
# Report classes to load
Report.report1 = MessageStatsReport

## Default settings for some routers settings
ProphetRouter.secondsInTimeUnit = 30
SprayAndWaitRouter.nrofCopies = 6
SprayAndWaitRouter.binaryMode = true

## Optimization settings -- these affect the speed of the simulation
## see World class for details.
Optimization.cellSizeMult = 5
Optimization.randomizeUpdateOrder = true


## GUI settings

# GUI underlay image settings
GUI.UnderlayImage.fileName = data/helsinki_underlay.png
# Image offset in pixels (x, y)
GUI.UnderlayImage.offset = 64, 20
# Scaling factor for the image
GUI.UnderlayImage.scale = 4.75
# Image rotation (radians)
GUI.UnderlayImage.rotate = -0.015

# how many events to show in the log panel (default = 30)
GUI.EventLogPanel.nrofEvents = 100
# Regular Expression log filter 
(see Pattern-class from the Java API for RE-matching details)
#GUI.EventLogPanel.REfilter = .*p[1-9]<->p[1-9]$
\end{verbatim}
\end{framed}

\subsection{ActiveRouter.java}
\begin{framed}
\begin{verbatim}
/* 
 * Copyright 2010 Aalto University, ComNet
 * Released under GPLv3. See LICENSE.txt for details. 
 */
package routing;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Random;

import routing.util.EnergyModel;
import routing.util.MessageTransferAcceptPolicy;
import routing.util.RoutingInfo;
import util.Tuple;

import core.Connection;
import core.DTNHost;
import core.Message;
import core.MessageListener;
import core.NetworkInterface;
import core.Settings;
import core.SimClock;

/**
 * Superclass of active routers. Contains convenience methods (e.g. 
 * {@link #getNextMessageToRemove(boolean)}) and watching of 
   sending connections (see
 * {@link #update()}).
 */
public abstract class ActiveRouter extends MessageRouter {
	/** Delete delivered messages -setting id ({@value}). Boolean valued.
	 * If set to true and final recipient of a message rejects it because it
	 * already has it, the message is deleted from buffer. Default=false. */
	public static final String DELETE_DELIVERED_S = "deleteDelivered";
	/** should messages that final recipient marks as delivered be deleted
	 * from message buffer */
	protected boolean deleteDelivered;
		
	/** prefix of all response message IDs */
	public static final String RESPONSE_PREFIX = "R_";
	
	/** how often TTL check (discarding old messages) is performed */
	private static int ttlCheckInterval = 60;
	/** connection(s) that are currently used for sending */
	protected ArrayList<Connection> sendingConnections;
	/** sim time when the last TTL check was done */
	private double lastTtlCheck;
	
	private MessageTransferAcceptPolicy policy;
	private EnergyModel energy;

	/**
	 * Constructor. Creates a new message router based on the settings in
	 * the given Settings object.
	 * @param s The settings object
	 */
	public ActiveRouter(Settings s) {
		super(s);
		
		this.policy = new MessageTransferAcceptPolicy(s);
		
		this.deleteDelivered = s.getBoolean(DELETE_DELIVERED_S, false);
		
		if (s.contains(EnergyModel.INIT_ENERGY_S)) {
			this.energy = new EnergyModel(s);
		} else {
			this.energy = null; /* no energy model */
		}
		
		ttlCheckInterval = 
				(new Settings().getBoolean(Message.TTL_SECONDS_S, false) 
						? 1 : 60);
	}
	
	/**
	 * Copy constructor.
	 * @param r The router prototype where setting values are copied from
	 */
	protected ActiveRouter(ActiveRouter r) {
		super(r);
		this.deleteDelivered = r.deleteDelivered;
		this.policy = r.policy;
		this.energy = (r.energy != null ? r.energy.replicate() : null);
	}
	
	@Override
	public void init(DTNHost host, List<MessageListener> mListeners) {
		super.init(host, mListeners);
		this.sendingConnections = new ArrayList<Connection>(1);
		this.lastTtlCheck = 0;
	}
	
	/**
	 * Called when a connection's state changes. 
       If energy modeling is enabled,
	 * and a new connection is created to this node, 
       reduces the energy for the
	 * device discovery (scan response) amount
	 * @param @con The connection whose state changed
	 */
	@Override
	public void changedConnection(Connection con) {
		if (this.energy != null && con.isUp() && !con.isInitiator(getHost())) {
			this.energy.reduceDiscoveryEnergy();
		}
	}
	
	@Override
	public boolean requestDeliverableMessages(Connection con) {
		if (isTransferring()) {
			return false;
		}
		
		DTNHost other = con.getOtherNode(getHost());
		/* do a copy to avoid concurrent modification exceptions 
		 * (startTransfer may remove messages) */
		ArrayList<Message> temp = 
			new ArrayList<Message>(this.getMessageCollection());
		for (Message m : temp) {
			if (other == m.getTo()) {
				if (startTransfer(m, con) == RCV_OK) {
					return true;
				}
			}
		}
		return false;
	}
	
	@Override 
	public boolean createNewMessage(Message m) {
		makeRoomForNewMessage(m.getSize());
		return super.createNewMessage(m);	
	}
	
	@Override
	public int receiveMessage(Message m, DTNHost from) {
		int recvCheck = checkReceiving(m, from); 
		if (recvCheck != RCV_OK) {
			return recvCheck;
		}

		// seems OK, start receiving the message
		return super.receiveMessage(m, from);
	}
	
	@Override
	public Message messageTransferred(String id, DTNHost from) {
		Message m = super.messageTransferred(id, from);

		/**
		 *  N.B. With application support the following if-block
		 *  becomes obsolete, and the response size should be configured 
		 *  to zero.
		 */
		// check if msg was for this host and a response was requested
		if (m.getTo() == getHost() && m.getResponseSize() > 0) {
			// generate a response message
			Message res = new Message(this.getHost(),m.getFrom(), 
					RESPONSE_PREFIX+m.getId(), m.getResponseSize());
			this.createNewMessage(res);
			this.getMessage(RESPONSE_PREFIX+m.getId()).setRequest(m);
		}
		
		return m;
	}
	
	/**
	 * Returns a list of connections this host currently has with other hosts.
	 * @return a list of connections this host currently has with other hosts
	 */
	protected List<Connection> getConnections() {
		return getHost().getConnections();
	}
	
	/**
	 * Tries to start a transfer of message using a connection. Is starting
	 * succeeds, the connection is added to the watch list 
       of active connections
	 * @param m The message to transfer
	 * @param con The connection to use
	 * @return the value returned by 
	 * {@link Connection#startTransfer(DTNHost, Message)}
	 */
	protected int startTransfer(Message m, Connection con) {
		int retVal;
		
		if (!con.isReadyForTransfer()) {
			return TRY_LATER_BUSY;
		}
		
		if (!policy.acceptSending(getHost(), 
				con.getOtherNode(getHost()), con, m)) {
			return MessageRouter.DENIED_POLICY;
		}
		
		retVal = con.startTransfer(getHost(), m);
		if (retVal == RCV_OK) { // started transfer
			addToSendingConnections(con);
		}
		else if (deleteDelivered && retVal == DENIED_OLD && 
				m.getTo() == con.getOtherNode(this.getHost())) {
			/* final recipient has already received the msg -> delete it */
			this.deleteMessage(m.getId(), false);
		}
		
		return retVal;
	}
	
	/**
	 * Makes rudimentary checks (that we have at least one message and one
	 * connection) about can this router start transfer.
	 * @return True if router can start transfer, false if not
	 */
	protected boolean canStartTransfer() {
		if (this.getNrofMessages() == 0) {
			return false;
		}
		if (this.getConnections().size() == 0) {
			return false;
		}
		
		return true;
	}
	
	/**
	 * Checks if router "wants" to start receiving message (i.e. router 
	 * isn't transferring, doesn't have the message and has room for it).
	 * @param m The message to check
	 * @return A return code similar to 
	 * {@link MessageRouter#receiveMessage(Message, DTNHost)}, i.e. 
	 * {@link MessageRouter#RCV_OK} if receiving seems to be OK, 
	 * TRY_LATER_BUSY if router is transferring, DENIED_OLD if the router
	 * is already carrying the message or it has been delivered to
	 * this router (as final recipient), or DENIED_NO_SPACE if the message
	 * does not fit into buffer
	 */
	protected int checkReceiving(Message m, DTNHost from) {
		if (isTransferring()) {
			return TRY_LATER_BUSY; // only one connection at a time
		}
	
		if ( hasMessage(m.getId()) || isDeliveredMessage(m) ||
				super.isBlacklistedMessage(m.getId())) {
			return DENIED_OLD; // already seen this message -> reject it
		}
		
		if (m.getTtl() <= 0 && m.getTo() != getHost()) {
			/* TTL has expired and this host is not the final recipient */
			return DENIED_TTL; 
		}

		if (energy != null && energy.getEnergy() <= 0) {
			return MessageRouter.DENIED_LOW_RESOURCES;
		}
		
		if (!policy.acceptReceiving(from, getHost(), m)) {
			return MessageRouter.DENIED_POLICY;
		}
		
		/* remove oldest messages but not the ones being sent */
		if (!makeRoomForMessage(m.getSize())) {
			return DENIED_NO_SPACE; // couldn't fit into buffer -> reject
		}
		
		return RCV_OK;
	}
	
	/** 
	 * Removes messages from the buffer (oldest first) until
	 * there's enough space for the new message.
	 * @param size Size of the new message 
	 * transferred, the transfer is aborted before message is removed
	 * @return True if enough space could be freed, false if not
	 */
	protected boolean makeRoomForMessage(int size){
		if (size > this.getBufferSize()) {
			return false; // message too big for the buffer
		}
			
		int freeBuffer = this.getFreeBufferSize();
		/* delete messages from the buffer until there's enough space */
		while (freeBuffer < size) {
            // don't remove msgs being sent
			Message m = getNextMessageToRemove(true);

			if (m == null) {
				return false; // couldn't remove any more messages
			}			
			
			/* delete message from the buffer as "drop" */
			deleteMessage(m.getId(), true);
			freeBuffer += m.getSize();
		}
		
		return true;
	}
	
	/**
	 * Drops messages whose TTL is less than zero.
	 */
	protected void dropExpiredMessages() {
		Message[] messages = getMessageCollection().toArray(new Message[0]);
		for (int i=0; i<messages.length; i++) {
			int ttl = messages[i].getTtl(); 
			if (ttl <= 0) {
				deleteMessage(messages[i].getId(), true);
			}
		}
	}
	
	/**
	 * Tries to make room for a new message. Current implementation simply
	 * calls {@link #makeRoomForMessage(int)} and ignores the return value.
	 * Therefore, if the message can't fit into buffer, the buffer is only 
	 * cleared from messages that are not being sent.
	 * @param size Size of the new message
	 */
	protected void makeRoomForNewMessage(int size) {
		makeRoomForMessage(size);
	}

	
	/**
	 * Returns the oldest (by receive time) message in the message buffer 
	 * (that is not being sent if excludeMsgBeingSent is true).
	 * @param excludeMsgBeingSent If true, excludes message(s) that are
	 * being sent from the oldest message check (i.e. if oldest message is
	 * being sent, the second oldest message is returned)
	 * @return The oldest message or null if no message could be returned
	 * (no messages in buffer or all messages in buffer are being sent and
	 * exludeMsgBeingSent is true)
	 */
	protected Message getNextMessageToRemove(boolean excludeMsgBeingSent) {
		Collection<Message> messages = this.getMessageCollection();
		Message oldest = null;
		for (Message m : messages) {
			
			if (excludeMsgBeingSent && isSending(m.getId())) {
				continue; // skip the message(s) that router is sending
			}
			
			if (oldest == null ) {
				oldest = m;
			}
			else if (oldest.getReceiveTime() > m.getReceiveTime()) {
				oldest = m;
			}
		}
		
		return oldest;
	}
	
	/**
	 * Returns a list of message-connections tuples of the messages whose
	 * recipient is some host that we're connected to at the moment.
	 * @return a list of message-connections tuples
	 */
	protected List<Tuple<Message, Connection>> getMessagesForConnected() {
		if (getNrofMessages() == 0 || getConnections().size() == 0) {
			/* no messages -> empty list */
			return new ArrayList<Tuple<Message, Connection>>(0); 
		}

		List<Tuple<Message, Connection>> forTuples = 
			new ArrayList<Tuple<Message, Connection>>();
		for (Message m : getMessageCollection()) {
			for (Connection con : getConnections()) {
				DTNHost to = con.getOtherNode(getHost());
				if (m.getTo() == to) {
					forTuples.add(new Tuple<Message, Connection>(m,con));
				}
			}
		}
		
		return forTuples;
	}
	
	/**
	 * Tries to send messages for the connections that are mentioned
	 * in the Tuples in the order they are in the list until one of
	 * the connections starts transferring or all tuples have been tried.
	 * @param tuples The tuples to try
	 * @return The tuple whose connection accepted the message or null if
	 * none of the connections accepted the message that was meant for them.
	 */
	protected Tuple<Message, Connection> tryMessagesForConnected(
			List<Tuple<Message, Connection>> tuples) {
		if (tuples.size() == 0) {
			return null;
		}
		
		for (Tuple<Message, Connection> t : tuples) {
			Message m = t.getKey();
			Connection con = t.getValue();
			if (startTransfer(m, con) == RCV_OK) {
				return t;
			}
		}
		
		return null;
	}
	
	 /**
	  * Goes trough the messages until the other node accepts one
	  * for receiving (or doesn't accept any). If a transfer is started, the
	  * connection is included in the list of sending connections.
	  * @param con Connection trough which the messages are sent
	  * @param messages A list of messages to try
	  * @return The message whose transfer was started or null if no 
	  * transfer was started. 
	  */
	protected Message tryAllMessages(Connection con, List<Message> messages) {
		for (Message m : messages) {
			int retVal = startTransfer(m, con); 
			if (retVal == RCV_OK) {
				return m;	// accepted a message, don't try others
			}
			else if (retVal > 0) { 
				return null; // should try later -> don't bother trying others
			}
		}
		
		return null; // no message was accepted		
	}

	/**
	 * Tries to send all given messages to all given connections. Connections
	 * are first iterated in the order they are in the list and for every
	 * connection, the messages are tried in the order they are in the list.
	 * Once an accepting connection is found, no other connections or messages
	 * are tried.
	 * @param messages The list of Messages to try
	 * @param connections The list of Connections to try
	 * @return The connections that started a transfer or 
       null if no connection
	 * accepted a message.
	 */
	protected Connection tryMessagesToConnections(List<Message> messages,
			List<Connection> connections) {
		for (int i=0, n=connections.size(); i<n; i++) {
			Connection con = connections.get(i);
			Message started = tryAllMessages(con, messages); 
			if (started != null) { 
				return con;
			}
		}
		
		return null;
	}
	
	/**
	 * Tries to send all messages that this router is carrying to all
	 * connections this node has. Messages are ordered using the 
	 * {@link MessageRouter#sortByQueueMode(List)}. See 
	 * {@link #tryMessagesToConnections(List, List)} for sending details.
	 * @return The connections that started a transfer or 
       null if no connection
	 * accepted a message.
	 */
	protected Connection tryAllMessagesToAllConnections(){
		List<Connection> connections = getConnections();
		if (connections.size() == 0 || this.getNrofMessages() == 0) {
			return null;
		}

		List<Message> messages = 
			new ArrayList<Message>(this.getMessageCollection());
		this.sortByQueueMode(messages);

		return tryMessagesToConnections(messages, connections);
	}
		
	/**
	 * Exchanges deliverable (to final recipient) messages between this host
	 * and all hosts this host is currently connected to. First all messages
	 * from this host are checked and then all other hosts are asked for
	 * messages to this host. If a transfer is started, the search ends.
	 * @return A connection that started a transfer or null if no transfer
	 * was started
	 */
	protected Connection exchangeDeliverableMessages() {
		List<Connection> connections = getConnections();

		if (connections.size() == 0) {
			return null;
		}
		
		@SuppressWarnings(value = "unchecked")
		Tuple<Message, Connection> t =
			tryMessagesForConnected(sortByQueueMode(getMessagesForConnected()));

		if (t != null) {
			return t.getValue(); // started transfer
		}
		
		// didn't start transfer to any node -> ask messages from connected
		for (Connection con : connections) {
			if (con.getOtherNode(getHost()).requestDeliverableMessages(con)) {
				return con;
			}
		}
		
		return null;
	}


	
	/**
	 * Shuffles a messages list so the messages are in random order.
	 * @param messages The list to sort and shuffle
	 */
	protected void shuffleMessages(List<Message> messages) {
		if (messages.size() <= 1) {
			return; // nothing to shuffle
		}
		
		Random rng = new Random(SimClock.getIntTime());
		Collections.shuffle(messages, rng);	
	}
	
	/**
	 * Adds a connections to sending connections which are monitored in
	 * the update.
	 * @see #update()
	 * @param con The connection to add
	 */
	protected void addToSendingConnections(Connection con) {
		this.sendingConnections.add(con);
	}
		
	/**
	 * Returns true if this router is transferring something at the moment or
	 * some transfer has not been finalized.
	 * @return true if this router is transferring something
	 */
	public boolean isTransferring() {
		if (this.sendingConnections.size() > 0) {
			return true; // sending something
		}
		
		List<Connection> connections = getConnections();
		
		if (connections.size() == 0) {
			return false; // not connected
		}
		
		for (int i=0, n=connections.size(); i<n; i++) {
			Connection con = connections.get(i);
			if (!con.isReadyForTransfer()) {
				return true;	// a connection isn't ready for new transfer
			}
		}
		
		return false;		
	}
	
	/**
	 * Returns true if this router is currently sending a message with 
	 * <CODE>msgId</CODE>.
	 * @param msgId The ID of the message
	 * @return True if the message is being sent false if not
	 */
	public boolean isSending(String msgId) {
		for (Connection con : this.sendingConnections) {
			if (con.getMessage() == null) {
				continue; // transmission is finalized
			}
			if (con.getMessage().getId().equals(msgId)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Returns true if the node has energy left (i.e., energy modeling is
	 * enabled OR (is enabled and model has energy left))
	 * @return has the node energy
	 */
	public boolean hasEnergy() {
		return this.energy == null || this.energy.getEnergy() > 0;
	}
	
	/**
	 * Checks out all sending connections to finalize the ready ones 
	 * and abort those whose connection went down. Also drops messages
	 * whose TTL <= 0 (checking every one simulated minute).
	 * @see #addToSendingConnections(Connection)
	 */
	@Override
	public void update() {		
		super.update();
		
		/* in theory we can have multiple sending connections even though
		  currently all routers allow only one concurrent sending connection */
		for (int i=0; i<this.sendingConnections.size(); ) {
			boolean removeCurrent = false;
			Connection con = sendingConnections.get(i);
			
			/* finalize ready transfers */
			if (con.isMessageTransferred()) {
				if (con.getMessage() != null) {
					transferDone(con);
					con.finalizeTransfer();
				} /* else: some other entity aborted transfer */
				removeCurrent = true;
			}
			/* remove connections that have gone down */
			else if (!con.isUp()) {
				if (con.getMessage() != null) {
					transferAborted(con);
					con.abortTransfer();
				}
				removeCurrent = true;
			} 
			
			if (removeCurrent) {
				// if the message being sent was holding excess buffer, free it
				if (this.getFreeBufferSize() < 0) {
					this.makeRoomForMessage(0);
				}
				sendingConnections.remove(i);
			}
			else {
				/* index increase needed only if nothing was removed */
				i++;
			}
		}
		
		/* time to do a TTL check and drop old messages? Only if not sending */
		if (SimClock.getTime() - lastTtlCheck >= ttlCheckInterval && 
				sendingConnections.size() == 0) {
			dropExpiredMessages();
			lastTtlCheck = SimClock.getTime();
		}
		
		if (energy != null) {
			/* TODO: add support for other interfaces */
			NetworkInterface iface = getHost().getInterface(1);
			energy.update(iface, getHost().getComBus());
		}
	}
	
	/**
	 * Method is called just before a transfer is aborted at {@link #update()} 
	 * due connection going down. This happens on the sending host. 
	 * Subclasses that are interested of the event may want to override this. 
	 * @param con The connection whose transfer was aborted
	 */
	protected void transferAborted(Connection con) { }
	
	/**
	 * Method is called just before a transfer is finalized 
	 * at {@link #update()}.
	 * Subclasses that are interested of the event may want to override this.
	 * @param con The connection whose transfer was finalized
	 */
	protected void transferDone(Connection con) { }
	
	@Override
	public RoutingInfo getRoutingInfo() {
		RoutingInfo top = super.getRoutingInfo();
		if (energy != null) {
			top.addMoreInfo(new RoutingInfo("Energy level: " + 
					String.format("%.2f mAh", energy.getEnergy() / 3600)));
		}
		return top;
	}
	
}
\end{verbatim}
\end{framed}
\end{document}
